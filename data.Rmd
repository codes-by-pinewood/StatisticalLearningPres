---
title: "Untitled"
output: html_document
date: "2024-05-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}

#data_cleaned <- na.omit(data)
library(readr)
library(paran)
library(EFA.dimensions)
library(caret)
library(glmnet)
library(factoextra)
library(ggplot2)
library(knitr)
library(class)
library(FactoMineR)
library(qgraph)
library(stats)
library(tidyverse)
library(ggplot2)

```

```{r}

dataset <- read.csv("data.csv", sep="\t")

dataset$EQ_score <- rowSums(dataset[, grep("^E", names(dataset))])
dataset$SQ_score <- rowSums(dataset[, grep("^S", names(dataset))])


sampleSize <- floor(0.7 * nrow(dataset))

trainIndex <- sample(seq_len(nrow(dataset)), size = sampleSize)

train_set<- dataset[trainIndex, ]
test_set <- dataset[-trainIndex, ]
```

## 10 fold cross validation 

You can also embed plots, for example:

```{r pressure, echo=FALSE}
set.seed(123)

#split the total train data into 10 groups 
ctrl <- trainControl(method = "cv", number = 10)

#test values of k from 1 to 15 
k_vals <- 1:15
cv_results <- data.frame(k = k_vals, accuracy = numeric(length(k_vals)))

#for each value of k, create a model that is trained using k fold cross validation
# and calculate the accuracy of that model 
for (i in seq_along(k_vals)) {
  knn_model <- train(accuracy ~ E1+E2+E3+E4+E5+E6, data = train_set, 
                     method = "knn", trControl = ctrl, tuneGrid = data.frame(k = k_vals[i]))
  cv_results[i, "accuracy"] <- max(knn_model$results$Accuracy)
}

#find the optimal k, k with highest accuracy  
optimal_k <- cv_results$k[which.max(cv_results$accuracy)]
print(optimal_k)
```
```{r}

pca_result <- prcomp(dataset, scale=TRUE)
plot(pca_result, xlab="Principal Components", main="Principle Component Analysis" )
abline(h = 1, col = "blue", lty = 1) #eigenvalues should be > 1 

par(mfrow=c(2,2))
prop_var_expl_sc = summary(pca_result)$importance[2,]
cum_var_expl_sc = summary(pca_result)$importance[3,]

plot(prop_var_expl_sc, type="b", xlab="Component number", ylab="Proportion of variance explained", ylim=c(0,1))
plot(cum_var_expl_sc, type="b", xlab="Number of components", ylab="Cumulative variance explained", ylim=c(0,1))
```

```{r}

MAP(dataset, corkind='pearson', verbose = TRUE)
```

```{r}
library(paran)
parallel_result <- paran(dataset)
```

```{r}
pca_data <- dataset[, grep("^(E|S)", names(dataset))]

# Standardize the data (mean = 0, variance = 1)
pca_data_scaled <- scale(pca_data)

# Perform PCA
pca_result <- prcomp(pca_data_scaled, center = TRUE, scale. = TRUE)

# Print a summary of the PCA results
summary(pca_result)
```



```{r}
fviz_eig(pca_result)

# Biplot to visualize the first two principal components
fviz_pca_biplot(pca_result, repel = TRUE, col.var = "#2E9FDF", col.ind = "#696969")

# Optional: Visualize the individuals with color coding by profile (Empath/Systemizer)
dataset$Profile <- ifelse(dataset$EQ_score > dataset$SQ_score, "Empath", "Systemizer")
fviz_pca_ind(pca_result, geom.ind = "point", col.ind = dataset$Profile, 
             palette = c("red", "blue"), addEllipses = TRUE, legend.title = "Profile")
```
# Looking at the dataset I think the first 2 variables 
# K Means Clustering 


```{r}
fviz_contrib(pca_result, choice = "var", axes = 1, top = 10) + xlab("Variables from V1 onwards (truncated)") + theme(axis.title.x = element_text(size = 14),axis.title.y = element_text(size = 14))
fviz_contrib(pca_result, choice = "var", axes = 2, top = 10) + xlab("Variables from V1 onwards (truncated)") + theme(axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14))
fviz_contrib(data.pca, choice = "var", axes = 3, top = 10) + xlab("Variables from V1 onwards (truncated)") + theme(axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14))
fviz_contrib(data.pca, choice = "var", axes = 4, top = 10) + xlab("Variables from V1 onwards (truncated)") + theme(axis.title.x = element_text(size = 14),axis.title.y = element_text(size = 14))
fviz_contrib(data.pca, choice = "var", axes = 5, top = 10) + xlab("Variables from V1 onwards (truncated)") + theme(axis.title.x = element_text(size = 14),
axis.title.y = element_text(size = 14))
```

```{r}
pca_data <- as.data.frame(pca_result$rotation[,1:5]) 

fviz_nbclust(x = pca_data ,FUNcluster = kmeans, method = 'wss' )
```


```{r}
pca_data <- as.data.frame(pca_result$rotation[,1:7]) 

fviz_nbclust(x = pca_data ,FUNcluster = kmeans, method = 'wss' )
```


```{r}
k = 7
km.res <- kmeans(pca_data, centers=k, nstart = 25)

#print(km.res)

fviz_cluster(km.res, data=pca_data)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
